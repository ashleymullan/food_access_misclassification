bias_mle = mean((beta1_mle - beta1) / beta1), ese_mle = sd(beta1_mle),
ase_mle = mean(se_beta1_mle),
cp_mle = cp(est = beta1_mle, se = se_beta1_mle, truth = beta1)
) |>
dplyr::mutate(re_cc = (ese_gs ^ 2) / (ese_cc ^ 2),
re_mle = (ese_gs ^ 2) / (ese_mle ^ 2))
}
results_list |> names()
#visual inspection: not needed
results_list$`one-sided-vary-ppv.csv` |>
beta1_summary(ppv) |>
select(ese_mle, ase_mle, N, ppv) |>
round(digits = 5) |> View()
#visual inspection: not needed
results_list$`one-sided-vary-ppv.csv` |>
beta1_summary(ppv)# |>
#compute coverage proportion for Wald interval
cp <- function(est, se, truth) {
mean((est - 1.96 * se) <= truth & truth <= (est + 1.96 * se))
}
beta1_summary <- function(results_df, varied_var){
results_df |>
dplyr::select(c(N, {{varied_var}}, beta1,
beta1_gs, beta1_n, beta1_cc, beta1_mle,
se_beta1_mle)) |>
tidyr::drop_na() |>
dplyr::group_by(N, {{varied_var}}) |>
dplyr::summarize(bias_gs = mean((beta1_gs - beta1) / beta1), ese_gs = sd(beta1_gs),
bias_n = mean((beta1_n - beta1) / beta1), ese_n = sd(beta1_n),
bias_cc = mean((beta1_cc - beta1) / beta1), ese_cc = sd(beta1_cc),
bias_mle = mean((beta1_mle - beta1) / beta1), ese_mle = sd(beta1_mle),
ase_mle = mean(se_beta1_mle),
cp_mle = cp(est = beta1_mle, se = se_beta1_mle, truth = beta1)
) |>
dplyr::mutate(re_cc = (ese_gs ^ 2) / (ese_cc ^ 2),
re_mle = (ese_gs ^ 2) / (ese_mle ^ 2))
}
#visual inspection: not needed
results_list$`one-sided-vary-ppv.csv` |>
beta1_summary(ppv) #|>
#visual inspection: not needed
results_list$`one-sided-vary-ppv.csv` |>
beta1_summary(ppv) |>
select(ese_mle, ase_mle, N, ppv) |>
round(digits = 5) |> View()
#visual inspection: not needed
results_list$`one-sided-vary-ppv.csv` |>
beta1_summary(ppv) |>
dplyr::select(ese_mle, ase_mle, N, ppv) |>
round(digits = 5) |> View()
check_drops <- function(results_df, varied_var){
full_nrow <- results_df |> nrow()
check_nrow <- results_df |>
dplyr::select(c(N, {{varied_var}}, beta1,
beta1_gs, beta1_n, beta1_cc, beta1_mle,
se_beta1_mle)) |>
tidyr::drop_na() |> nrow()
drops <- full_nrow - check_nrow
perc <- round(drops / full_nrow * 100, 2)
print(paste0("You originally had ", full_nrow, " replicates but dropped ",
drops, " which is ", perc, "%."))
}
#check the drops
check_drops(results_list$`one-sided-vary-ppv.csv`, ppv)
22/10000
check_drops <- function(results_df, varied_var){
full_nrow <- results_df |> nrow()
check_nrow <- results_df |>
dplyr::select(c(N, {{varied_var}}, beta1,
beta1_gs, beta1_n, beta1_cc, beta1_mle,
se_beta1_mle)) |>
tidyr::drop_na() |> nrow()
drops <- full_nrow - check_nrow
perc <- round(drops / full_nrow * 100, 2)
print(paste0("You originally had ", full_nrow, " replicates but dropped ",
drops, ", which is ", perc, "%."))
}
#check the drops
check_drops(results_list$`one-sided-vary-ppv.csv`, ppv)
beep(8)
files
?stringr
?substr
letters
test <- "abcdefghijklm"
substr(test,1,10)
substr(files[1],1,10)
substr(files[1], 1, 14)
substr(files[1], 16)
substr(files[1], 16,length(files[1]))
substring(files[1], 16)
substring(files[1], 16) |> substring(-4)
substring(files[1], 16) |> substring(length(files[1]-4)
substring(files[1], 16) |> substring(length(files[1])-4)
substring(files[1], 16) |> stringi::stri_reverse()
substring(files[1], 16) |> stringi::stri_reverse() |> substring(5) |> stringi::stri_reverse()
check_drops(results_list[[1]], substring(files[1], 16) |> stringi::stri_reverse() |> substring(5) |> stringi::stri_reverse())
for(i in 1:total_variations){
#grab variable being varied
var <- substring(files[i], 16) |>
stringi::stri_reverse() |>
substring(5) |>
stringi::stri_reverse()
check_drops(results_list[[i]], var)
}
files
#check the drops (not needed but helpful)
for(i in 1:total_variations){
#grab variable being varied
var <- substring(files[i], 16) |>
stringi::stri_reverse() |>
substring(5) |>
stringi::stri_reverse()
if(var == "prev") var <- "beta0"
if(var == "prevrat") var <- "beta1"
check_drops(results_list[[i]], var)
}
results_list[[5]] |> group_by(N, ppv) |> summarize(n = n())
results_list[[5]] |> dplyr::group_by(N, ppv) |> dplyr::summarize(n = n())
#function to format numbers for LaTeX
format_num = function(num, digits = 3) {
paste0("$", format(round(num, 3), nsmall = digits), "$")
}
files
## Format for LaTeX
q_table <- results_list[[2]] |>
beta1_summary(q) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 3)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 2)))
prevrat_table <- results_list[[4]] |>
beta1_summary(beta1) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 3)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 1)))
results_list |> names()
tppv_table <- results_list[[5]] |>
beta1_summary(ppv) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 3)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 1)))
tppv_table |> head()
results_list[[5]] |>
beta1_summary(ppv) |> head()
tppv_table <- results_list[[5]] |>
beta1_summary(ppv) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 3)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 1)))
tppv_table |> View()
colnames(ttpv_table) = c("$\\pmb{N}$", "$\\pmb{PPV}$", #GGNNCCMM MMCM
rep(c("Bias", "ESE"), times = 4),
"ASE","CP", "RE", "RE")
colnames(tppv_table) = c("$\\pmb{N}$", "$\\pmb{PPV}$", #GGNNCCMM MMCM
rep(c("Bias", "ESE"), times = 4),
"ASE","CP", "RE", "RE")
tppv_table |> View()
tppv_table <- tppv_table[,c(1:8,13,9:12,14)] #input to spit_tex_code
#spit out TeX code
spit_tex_code <- function(prepped_table){
prepped_table |>
kable(format = "latex",
booktabs = TRUE,
escape = FALSE,
align = "ccrcrcrccrcccc") |>
kable_styling() |>
add_header_above(header = c(" " = 2,
"Gold Standard" = 2,
"Naive" = 2,
"Complete Case" = 3, #bias, ese, re
"MLE" = 5), #bias, ese, ase, re
bold = TRUE) |>
row_spec(row = 0, bold = TRUE)
}
spit_tex_code(tppv_table)
library(kableExtra)
spit_tex_code(tppv_table)
results_list[[5]] |> head()
c(-2.277854, 0.1764544) |> exp()
tppv_table <- results_list[[5]] |>
beta1_summary(ppv) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 4)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 1)))
colnames(tppv_table) = c("$\\pmb{N}$", "$\\pmb{PPV}$", #GGNNCCMM MMCM
rep(c("Bias", "ESE"), times = 4),
"ASE","CP", "RE", "RE")
tppv_table <- tppv_table[,c(1:8,13,9:12,14)] #input to spit_tex_code
#spit out TeX code
spit_tex_code <- function(prepped_table){
prepped_table |>
kable(format = "latex",
booktabs = TRUE,
escape = FALSE,
align = "ccrcrcrccrcccc") |>
kable_styling() |>
add_header_above(header = c(" " = 2,
"Gold Standard" = 2,
"Naive" = 2,
"Complete Case" = 3, #bias, ese, re
"MLE" = 5), #bias, ese, ase, re
bold = TRUE) |>
row_spec(row = 0, bold = TRUE)
}
spit_tex_code(tppv_table)
tppv_table <- results_list[[5]] |>
beta1_summary(ppv) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 5)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 1)))
colnames(tppv_table) = c("$\\pmb{N}$", "$\\pmb{PPV}$", #GGNNCCMM MMCM
rep(c("Bias", "ESE"), times = 4),
"ASE","CP", "RE", "RE")
tppv_table <- tppv_table[,c(1:8,13,9:12,14)] #input to spit_tex_code
spit_tex_code(tppv_table)
tppv_table <- results_list[[5]] |>
beta1_summary(ppv) |>
mutate(across(c(3:13),
~ format_num(.x, digits = 3)))  |>
mutate(across(c(2),
~ format_num(.x, digits = 1)))
colnames(tppv_table) = c("$\\pmb{N}$", "$\\pmb{PPV}$", #GGNNCCMM MMCM
rep(c("Bias", "ESE"), times = 4),
"ASE","CP", "RE", "RE")
tppv_table <- tppv_table[,c(1:8,13,9:12,14)] #input to spit_tex_code
spit_tex_code(tppv_table)
results_list[[5]] |>
beta1_summary(ppv) |> View()
results_list[[5]] |>
beta1_summary(ppv) |> pull(bias_gs)
3 * 0.016
dbinom(1,6,1/3)/dbinom(1,6,1/2)
?dgeom
dgeom(5,1/3)/dgeom(5,1/2)
a = -2
b = 1/2
c = 3.95
pm = c(1,-1)
(-b + pm*sqrt(b^2-4*a*c))/(2*a)
?case_when
power2 <- function(s,t){
low <- 2*t
mid <- 2*t + 1
hi <- 2*t + 2
p <- case_when(
s <= low ~ 0
s > low & s <= mid ~ 0.5*s^2 - low*s - 0.5*low^2 + 4*t^2
power2 <- function(s,t){
low <- 2*t
mid <- 2*t + 1
hi <- 2*t + 2
p <- case_when(
s <= low ~ 0,
s > low & s <= mid ~ 0.5*s^2 - low*s - 0.5*low^2 + 4*t^2,
s > mid & s <= hi ~ -0.5*s^2 + hi*s + 0.5*mid^2 - hi*mid,
s > hi ~ 1
)
p
}
theta <- -1:1
theta
theta <- seq(-1,1)/100
theta
theta <- seq(-1,1,0.01)
theta
theta <- seq(-2,2,0.01)
theta
pt <- rep(NA, times = length(theta))
for(i in 1:length(theta)) pt[i] <- power2(1.54, t)
for(i in 1:length(theta)) pt[i] <- power2(1.54, theta[i])
data.frame(x = theta, y = pt) |> ggplot2(aes(x = x, y = y)) + geom_line()
data.frame(x = theta, y = pt) |> ggplot(aes(x = x, y = y)) + geom_line()
data.frame(x = theta, y = pt) |> ggplot(aes(x = x, y = y)) +
geom_line() + theme_classic()
data.frame(x = theta, y = pt) |> ggplot(aes(x = x, y = y)) +
geom_point()() + theme_classic() +
labs(x = "theta", y = "power", title = "1B")
data.frame(x = theta, y = pt) |> ggplot(aes(x = x, y = y)) +
geom_point() + theme_classic() +
labs(x = "theta", y = "power", title = "1B")
3141/28805
3135/28805
3100/28805
3000/28805
2000/28805
2800/28806
2800/28805
?lspline
#Question 2
q2 <- readRDS("data.Rds")
#Question 2
dir <- paste0("/Users/ashleymullan/Documents/",
"Vanderbilt/Coursework/Spring-2025/inference/")
q2 <- paste0(dir, "data.Rds") |> readRDS()
q2 |> head()
q2 |> View()
length(q2)
q2n <- length(q2) ## set N = 100
q2a_mu <- sum(q2) / q2n
q2a_mu
pi
s <- 0
for(i in 1:100) s <- s + q2[i]*q2[i]
s
sum(q2^2)
q2a_beta <- sqrt(3) / pi * sqrt((sum(q2^2)/2) - (q2a_mu)^2)
q2a_beta
sd(q2)
(sum(q2^2)/2)
(q2a_mu)^2
summary(q2)
333.8729 - 3.896226
q2a_beta <- sqrt(3) / pi * sqrt((sum(q2^2)/q2n) - (q2a_mu)^2)
q2a_beta
q2a_mu; q2a_beta
q2b_score_mu <- function(mb){
x <- q2
mu <- mb[1]
beta <- mb[2]
n <- length(x)
first <- n * mu / beta
inner <- (mu - x) / beta
second <- 2 / beta * sum(exp(inner) / (1 + exp(inner)))
first - second
}
q2b_score_beta <- function(mb){
x <- q2
mu <- mb[1]
beta <- mb[2]
n <- length(x)
first <- sum(x - mu) / beta^2 - n / beta
inner <- (mu - x) / beta
second <- 2 * sum(((x - mu)/beta^2)*exp(inner)/(1 + exp(inner)))
first - second
}
q2b_hess_mu <- function(mb){
x <- q2
mu <- mb[1]
beta <- mb[2]
n <- length(x)
first <- n / beta
inner <- (mu - x) / beta
second <- 2 / beta * sum((1 / beta) * (exp(inner) ) / (1 + exp(inner))^2)
first - second
}
q2b_hess_mixed <- function(mb){
x <- q2
mu <- mb[1]
beta <- mb[2]
n <- length(x)
first <- -1 * n * mu / beta^2
inner <- (mu - x) / beta
second <- 2 / beta * sum((1 / beta) * (exp(inner) ) / (1 + exp(inner))^2)
third <- 2 / beta^2 * sum((exp(inner)) / (1 + exp(inner)))
first - second + third
}
q2b_hess_beta <- function(mb){
x <- q2
mu <- mb[1]
beta <- mb[2]
n <- length(x)
first <- -2 * sum(x - mu) / beta^3 + n / beta^2
inner <- (mu - x) / beta
second <- 2 * sum(((1 + exp(inner))*((x-mu)/beta^2)*exp(inner)*(((x-mu)/beta^2) - 2/beta) - ((x-mu)/beta^2)^2*(exp(inner))^2) / (1 + exp(inner))^2)
first - second
}
S <- function(mb) {
c(q2b_score_mu(mb), q2b_score_beta(mb))
}
H <- function(mb) {
Hess <- matrix(c(q2b_hess_mu(mb),0,0,q2b_hess_beta(mb)),nrow=2)
Hess[1,2] <- Hess[2,1] <- q2b_hess_mixed(mb)
return(Hess)
}
mb <- c(2,1) ##initialize
while (max(abs(S(mb)))> 1e-7) mb <- mb - solve(H(mb))%*%S(mb) ## Newton-Raphson
mb
# Local maximum if H is negative definite
eigen(H(mb))$values # Are all eigenvalues negative?
library(matrixcalc)
install.packages("matrixcalc")
library(matrixcalc)
is.positive.definite(-H(mb))
q2a_mu; q2a_beta
mb
mus <- seq(0,3, by = 0.001)
mus
length(mus)
mb
q2a_beta
q2n
mus <- seq(0,3, by = 0.001)
betas <- seq(0,3, by = 0.001)
ll <- rep(NA, times = 3001)
for(i in 1:3001){
m <- mus[i]
b <- betas[i]
inner <- (m - q2)/b
(-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
plot_ly(x=m,y=b,z=ll, type="surface")
library(plotly)
install.packages('plotly')
library(plotly)
plot_ly(x=m,y=b,z=ll, type="surface")
?plotly
plot_ly(x=m,y=b,z=ll, type="surface")
max(ll)
mus <- seq(0.001,3, by = 0.001)
betas <- seq(0.001,3, by = 0.001)
mus
length(mus)
mus <- seq(0.001,3, by = 0.001)
betas <- seq(0.001,3, by = 0.001)
ll <- rep(NA, times = 3001)
for(i in 1:3000){
m <- mus[i]
b <- betas[i]
inner <- (m - q2)/b
(-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
plot_ly(x=m,y=b,z=ll, type="surface")
max(ll)
ll <- rep(NA, times = 3000)
for(i in 1:3000){
m <- mus[i]
b <- betas[i]
inner <- (m - q2)/b
(-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
max(ll)
for(i in 1:3000){
m <- mus[i]
b <- betas[i]
inner <- (m - q2)/b
ll[i] <- (-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
max(ll)
plot_ly(x=m,y=b,z=ll, type="surface")
plot_ly(x=mus,y=betas,z=ll, type="surface")
mus <- seq(0.001,3, by = 0.001)
betas <- seq(0.001,3, by = 0.001)
ll <- rep(NA, times = 3000)
for(i in 1:3000){
m <- mus[i]
b <- betas[i]
inner <- (m - q2)/b
ll[i] <- (-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
plot_ly(x=mus,y=betas,z=ll, type="surface")
max(ll)
data.frame(mus, betas, ll) |> dplyr::arrange(ll)
data.frame(mus, betas, ll) |> dplyr::arrange(desc(ll))
data.frame(mus, betas, ll) |> dplyr::arrange(desc(ll)) |> head()
expand.grid(mus, betas) |> dim()
mus <- seq(0.001,3, by = 0.01)
betas <- seq(0.001,3, by = 0.01)
expand.grid(mus, betas) |> dim()
expand.grid(mus, betas) |> head()
expand.grid(mus = mus, betas = betas) |> head()
mb_grid <- expand.grid(mus = mus, betas = betas)
mb_grid |> dim()
mus <- seq(0.001,3, by = 0.01)
betas <- seq(0.001,3, by = 0.01)
mb_grid <- expand.grid(mus = mus, betas = betas)
ll <- rep(NA, times = 90000)
for(i in 1:length(ll)){
m <- mb_grid$mus[i]
b <- mb_grid$betas[i]
inner <- (m - q2)/b
ll[i] <- (-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
mb_grid |> dplyr::mutate(ll = ll) |> dplyr::arrange(desc(ll)) |> head()
mb
q2a_mu; q2a_beta
mb <- c(1.97,0.92) ##initialize
while (max(abs(S(mb)))> 1e-7) mb <- mb - solve(H(mb))%*%S(mb) ## Newton-Raphson
mb
mus <- seq(0.001,3, by = 0.01)
betas <- seq(0.001,3, by = 0.01)
mb_grid <- expand.grid(mus = mus, betas = betas)
ll <- rep(NA, times = 90000)
for(i in 1:length(ll)){
m <- mb_grid$mus[i]
b <- mb_grid$betas[i]
inner <- (m - q2)/b
ll[i] <- (-1/b)*sum(q2-m) - q2n*log(b) - 2*sum(log(1+exp(inner)))
}
mb_grid |> dplyr::mutate(ll = ll) |> dplyr::arrange(desc(ll)) |> head()
mb
q2a_mu; q2a_beta
mb_grid |> dplyr::mutate(ll = ll) |> dplyr::arrange(desc(ll)) |> head(15)
xt <- rpois(10)
xt <- rpois(10, 5)
yt <- rpois(10,5)
xt
yt
rat = rep(NA, times = 10)
for(i in 1:10) rat[i] = yt[i] / xt[i]
rat
rat = rat[1:9]
rat
xt = xt[1:9]
yt = yt[1:9]
sum(rat)
sum(yt)/sum(xt)
